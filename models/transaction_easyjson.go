// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package models

import (
	json "encoding/json"
	strfmt "github.com/go-openapi/strfmt"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson461f4b12DecodeGithubComElasticApmServerModels(in *jlexer.Lexer, out *Transaction) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "context":
			if in.IsNull() {
				in.Skip()
				out.Context = nil
			} else {
				if out.Context == nil {
					out.Context = new(Context)
				}
				(*out.Context).UnmarshalEasyJSON(in)
			}
		case "duration":
			if in.IsNull() {
				in.Skip()
				out.Duration = nil
			} else {
				if out.Duration == nil {
					out.Duration = new(float32)
				}
				*out.Duration = float32(in.Float32())
			}
		case "id":
			if in.IsNull() {
				in.Skip()
				out.ID = nil
			} else {
				if out.ID == nil {
					out.ID = new(strfmt.UUID)
				}
				(*out.ID).UnmarshalEasyJSON(in)
			}
		case "marks":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Marks = make(map[string]Mark)
				} else {
					out.Marks = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v1 Mark
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						if !in.IsDelim('}') {
							v1 = make(Mark)
						} else {
							v1 = nil
						}
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v2 float64
							v2 = float64(in.Float64())
							(v1)[key] = v2
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.Marks)[key] = v1
					in.WantComma()
				}
				in.Delim('}')
			}
		case "name":
			out.Name = string(in.String())
		case "result":
			out.Result = string(in.String())
		case "sampled":
			out.Sampled = bool(in.Bool())
		case "span_count":
			if in.IsNull() {
				in.Skip()
				out.SpanCount = nil
			} else {
				if out.SpanCount == nil {
					out.SpanCount = new(TransactionSpanCount)
				}
				easyjson461f4b12DecodeGithubComElasticApmServerModels1(in, &*out.SpanCount)
			}
		case "spans":
			if in.IsNull() {
				in.Skip()
				out.Spans = nil
			} else {
				in.Delim('[')
				if out.Spans == nil {
					if !in.IsDelim(']') {
						out.Spans = make(TransactionSpans, 0, 8)
					} else {
						out.Spans = TransactionSpans{}
					}
				} else {
					out.Spans = (out.Spans)[:0]
				}
				for !in.IsDelim(']') {
					var v3 *Span
					if in.IsNull() {
						in.Skip()
						v3 = nil
					} else {
						if v3 == nil {
							v3 = new(Span)
						}
						(*v3).UnmarshalEasyJSON(in)
					}
					out.Spans = append(out.Spans, v3)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "timestamp":
			if in.IsNull() {
				in.Skip()
				out.Timestamp = nil
			} else {
				if out.Timestamp == nil {
					out.Timestamp = new(strfmt.DateTime)
				}
				(*out.Timestamp).UnmarshalEasyJSON(in)
			}
		case "type":
			if in.IsNull() {
				in.Skip()
				out.Type = nil
			} else {
				if out.Type == nil {
					out.Type = new(string)
				}
				*out.Type = string(in.String())
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson461f4b12EncodeGithubComElasticApmServerModels(out *jwriter.Writer, in Transaction) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Context != nil {
		const prefix string = ",\"context\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(*in.Context).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"duration\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Duration == nil {
			out.RawString("null")
		} else {
			out.Float32(float32(*in.Duration))
		}
	}
	{
		const prefix string = ",\"id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.ID == nil {
			out.RawString("null")
		} else {
			(*in.ID).MarshalEasyJSON(out)
		}
	}
	if len(in.Marks) != 0 {
		const prefix string = ",\"marks\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v4First := true
			for v4Name, v4Value := range in.Marks {
				if v4First {
					v4First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v4Name))
				out.RawByte(':')
				if v4Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v5First := true
					for v5Name, v5Value := range v4Value {
						if v5First {
							v5First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v5Name))
						out.RawByte(':')
						out.Float64(float64(v5Value))
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	if in.Name != "" {
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	if in.Result != "" {
		const prefix string = ",\"result\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Result))
	}
	if in.Sampled {
		const prefix string = ",\"sampled\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Sampled))
	}
	if in.SpanCount != nil {
		const prefix string = ",\"span_count\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjson461f4b12EncodeGithubComElasticApmServerModels1(out, *in.SpanCount)
	}
	{
		const prefix string = ",\"spans\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Spans == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v6, v7 := range in.Spans {
				if v6 > 0 {
					out.RawByte(',')
				}
				if v7 == nil {
					out.RawString("null")
				} else {
					(*v7).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"timestamp\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Timestamp == nil {
			out.RawString("null")
		} else {
			(*in.Timestamp).MarshalEasyJSON(out)
		}
	}
	{
		const prefix string = ",\"type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		if in.Type == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Type))
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Transaction) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson461f4b12EncodeGithubComElasticApmServerModels(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Transaction) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson461f4b12EncodeGithubComElasticApmServerModels(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Transaction) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson461f4b12DecodeGithubComElasticApmServerModels(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Transaction) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson461f4b12DecodeGithubComElasticApmServerModels(l, v)
}
func easyjson461f4b12DecodeGithubComElasticApmServerModels1(in *jlexer.Lexer, out *TransactionSpanCount) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "dropped":
			if in.IsNull() {
				in.Skip()
				out.Dropped = nil
			} else {
				if out.Dropped == nil {
					out.Dropped = new(TransactionSpanCountDropped)
				}
				easyjson461f4b12DecodeGithubComElasticApmServerModels2(in, &*out.Dropped)
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson461f4b12EncodeGithubComElasticApmServerModels1(out *jwriter.Writer, in TransactionSpanCount) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Dropped != nil {
		const prefix string = ",\"dropped\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		easyjson461f4b12EncodeGithubComElasticApmServerModels2(out, *in.Dropped)
	}
	out.RawByte('}')
}
func easyjson461f4b12DecodeGithubComElasticApmServerModels2(in *jlexer.Lexer, out *TransactionSpanCountDropped) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "total":
			out.Total = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson461f4b12EncodeGithubComElasticApmServerModels2(out *jwriter.Writer, in TransactionSpanCountDropped) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Total != 0 {
		const prefix string = ",\"total\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float64(float64(in.Total))
	}
	out.RawByte('}')
}
